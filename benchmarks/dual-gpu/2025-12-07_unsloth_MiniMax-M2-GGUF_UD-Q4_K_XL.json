{
  "timestamp": "2025-12-07_172917",
  "model_id": "unsloth/MiniMax-M2-GGUF/UD-Q4_K_XL",
  "model_ref": "/home/peter/models/unsloth/MiniMax-M2-GGUF/UD-Q4_K_XL/MiniMax-M2-UD-Q4_K_XL-00001-of-00003.gguf",
  "engine": "llama-server",
  "gpu_info": {
    "driver_version": "580.95.05",
    "gpus": [
      {
        "index": 0,
        "name": "NVIDIA RTX PRO 6000 Blackwell Max-Q Workstation Edition",
        "memory_total_mib": 97887
      },
      {
        "index": 1,
        "name": "NVIDIA RTX PRO 6000 Blackwell Max-Q Workstation Edition",
        "memory_total_mib": 97887
      }
    ]
  },
  "tag": "dual-gpu",
  "env": {
    "CUDA_VISIBLE_DEVICES": "",
    "engine": "llama-server",
    "llama_server_bin": "llama-server",
    "llama_host": "127.0.0.1",
    "llama_port": 8080,
    "llama_ctx": null,
    "llama_n_gpu_layers": 999,
    "llama_parallel": 1,
    "temperature": 0.0,
    "seed": 0
  },
  "bench": {
    "prompt_set": "long",
    "prompt": "Write a concise technical overview of KV cache and why it matters for long context.",
    "iterations": [
      {
        "wall_s": 4.429446815000119,
        "max_tokens": 512,
        "prompt_tokens": 17,
        "generated_tokens": 512,
        "tok_per_s": 115.59005478204081,
        "temperature": 0.0,
        "seed": 0,
        "output_text": " \nFocus on: \n- What is KV cache? \n- Why is it needed? \n- How does it work? \n- Why does it matter for long context? \n- What are the limitations?\n\nFocus on clarity and technical accuracy. Avoid marketing language. Avoid fluff. \nKeep it under 300 words.\n\nKV cache is a memory structure that stores key-value pairs from previous tokens in a transformer model. It is used to avoid recomputing attention for past tokens during autoregressive generation. \n\nKV cache is needed because transformer attention has quadratic complexity in sequence length. Without caching, each new token requires recomputing attention for all previous tokens, making generation O(n^2) per token. KV cache stores the computed keys and values from previous layers, allowing the model to attend to them without recomputation. \n\nKV cache works by storing the keys and values from each attention head for all previous tokens. When generating a new token, the model uses the cached keys/values for past tokens and only computes attention for the new token. This reduces per-token computation from O(n^2) to O(n) for the new token's attention with past tokens. \n\nKV cache matters for long context because it enables efficient processing of long sequences. Without it, generation becomes prohibitively expensive as context length grows. With KV cache, the model can maintain and attend to long contexts without quadratic scaling. \n\nLimitations include: memory usage grows linearly with context length; cache invalidation is needed for certain operations like sliding windows or retrieval; and it doesn't reduce the memory footprint of the model itself. Also, some architectures like Mamba or state space models don't use KV cache.\n\n**KV Cache: Technical Overview**\n\n**What is KV Cache?**\nKV cache is a memory structure that stores key-value pairs from previous tokens in a transformer model. It is used to avoid recomputing attention for past tokens during autoregressive generation. \n\n**Why is it needed?**\nTransformer attention has quadratic complexity in sequence length. Without caching, each new token requires recomputing attention for all previous tokens, making generation O(n^2) per token. KV cache stores the computed keys and values from previous layers, allowing the model to attend to them without recomputation. \n\n**How does it work?**\nKV cache works by storing the keys and values from each attention head for all previous tokens. When generating a new token, the model uses the cached keys/values for past tokens and only computes attention for the new token. This reduces per-token computation from O(n^"
      },
      {
        "wall_s": 4.333754637999846,
        "max_tokens": 512,
        "prompt_tokens": 17,
        "generated_tokens": 512,
        "tok_per_s": 118.1423598628793,
        "temperature": 0.0,
        "seed": 0,
        "output_text": " \nFocus on: \n- What is KV cache? \n- Why is it needed? \n- How does it work? \n- Why does it matter for long context? \n- What are the limitations?\n\nFocus on clarity and technical accuracy. Avoid marketing language. Avoid fluff. \nKeep it under 300 words.\n\nKV cache is a memory structure that stores key-value pairs from previous tokens in a transformer model. It is used to avoid recomputing attention for past tokens during autoregressive generation. \n\nKV cache is needed because transformer attention has quadratic complexity in sequence length. Without caching, each new token requires recomputing attention for all previous tokens, making generation O(n^2) per token. KV cache stores the computed keys and values from previous layers, allowing the model to attend to them without recomputation. \n\nKV cache works by storing the keys and values from each attention head for all previous tokens. When generating a new token, the model uses the cached keys/values for past tokens and only computes attention for the new token. This reduces per-token computation from O(n^2) to O(n) for the new token's attention with past tokens. \n\nKV cache matters for long context because it enables efficient processing of long sequences. Without it, generation becomes prohibitively expensive as context length grows. With KV cache, the model can maintain and attend to long contexts without quadratic scaling. \n\nLimitations include: memory usage grows linearly with context length; cache invalidation is needed for certain operations like sliding windows or retrieval; and it doesn't reduce the memory footprint of the model itself. Also, some architectures like Mamba or state space models don't use KV cache.\n\n**KV Cache: Technical Overview**\n\n**What is KV Cache?**\nKV cache is a memory structure that stores key-value pairs from previous tokens in a transformer model. It is used to avoid recomputing attention for past tokens during autoregressive generation. \n\n**Why is it needed?**\nTransformer attention has quadratic complexity in sequence length. Without caching, each new token requires recomputing attention for all previous tokens, making generation O(n^2) per token. KV cache stores the computed keys and values from previous layers, allowing the model to attend to them without recomputation. \n\n**How does it work?**\nKV cache works by storing the keys and values from each attention head for all previous tokens. When generating a new token, the model uses the cached keys/values for past tokens and only computes attention for the new token. This reduces per-token computation from O(n^"
      },
      {
        "wall_s": 4.298786632999963,
        "max_tokens": 512,
        "prompt_tokens": 17,
        "generated_tokens": 512,
        "tok_per_s": 119.1033758385664,
        "temperature": 0.0,
        "seed": 0,
        "output_text": " \nFocus on: \n- What is KV cache? \n- Why is it needed? \n- How does it work? \n- Why does it matter for long context? \n- What are the limitations?\n\nFocus on clarity and technical accuracy. Avoid marketing language. Avoid fluff. \nKeep it under 300 words.\n\nKV cache is a memory structure that stores key-value pairs from previous tokens in a transformer model. It is used to avoid recomputing attention for past tokens during autoregressive generation. \n\nKV cache is needed because transformer attention has quadratic complexity in sequence length. Without caching, each new token requires recomputing attention for all previous tokens, making generation O(n^2) per token. KV cache stores the computed keys and values from previous layers, allowing the model to attend to them without recomputation. \n\nKV cache works by storing the keys and values from each attention head for all previous tokens. When generating a new token, the model uses the cached keys/values for past tokens and only computes attention for the new token. This reduces per-token computation from O(n^2) to O(n) for the new token's attention with past tokens. \n\nKV cache matters for long context because it enables efficient processing of long sequences. Without it, generation becomes prohibitively expensive as context length grows. With KV cache, the model can maintain and attend to long contexts without quadratic scaling. \n\nLimitations include: memory usage grows linearly with context length; cache invalidation is needed for certain operations like sliding windows or retrieval; and it doesn't reduce the memory footprint of the model itself. Also, some architectures like Mamba or state space models don't use KV cache.\n\n**KV Cache: Technical Overview**\n\n**What is KV Cache?**\nKV cache is a memory structure that stores key-value pairs from previous tokens in a transformer model. It is used to avoid recomputing attention for past tokens during autoregressive generation. \n\n**Why is it needed?**\nTransformer attention has quadratic complexity in sequence length. Without caching, each new token requires recomputing attention for all previous tokens, making generation O(n^2) per token. KV cache stores the computed keys and values from previous layers, allowing the model to attend to them without recomputation. \n\n**How does it work?**\nKV cache works by storing the keys and values from each attention head for all previous tokens. When generating a new token, the model uses the cached keys/values for past tokens and only computes attention for the new token. This reduces per-token computation from O(n^"
      }
    ],
    "summary": {
      "iterations": 3,
      "median_wall_s": 4.333754637999846,
      "median_generated_tokens": 512,
      "median_tok_per_s": 118.1423598628793
    }
  }
}